<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>计算理论 on Lingerois</title>
    <link>https://flyzebraV.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/</link>
    <description>Recent content in 计算理论 on Lingerois</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Tue, 05 Mar 2019 12:06:45 +0000</lastBuildDate><atom:link href="https://flyzebraV.github.io/categories/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>计算复杂性(1) 自动机与正则语言</title>
      <link>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A71-%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Tue, 05 Mar 2019 12:06:45 +0000</pubDate>
      
      <guid>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A71-%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80/</guid>
      <description>计算问题 什么是计算机? 计算, 就是解决某个具体问题的算法, 得出相应的答案. 计算机就是能执行某个具体算法的机器. 即Computer就用来是Compute的机器. 此外, 讨论什么是机器, 对我们研究计算机科学毫无帮助, 你只需要知道, 计算机就是用来执行算法的机器. 我们要做的就是, 用最简单的理论模型, 最大程度的抽象化我们现有的计算机.
语言  定义 语言
一个字母表(alphabet)是一个非空有限集合, 该集合中的元素称为符号(symbol).
一个字母表$\Sigma$上的语言(language)是$\Sigma$中的元素构成的有限序列(称为串, 即string)的集合.
 例如字母表$\Sigma={0,1}$, 则我们可以定义一个$\Sigma$上的语言$L={x_1x_2\cdots x_n|\text{如果}x_i= 0,则x_{i+1}= 0}$, 则该语言为 $$ L={\varepsilon, 0,1,10,11,100,110,111,\cdots} $$ 即所有的$1$都出现在任何$0$之前的串. 其中, $\varepsilon$表示空串, 即长度为$0$的串.
这里要注意的是
 我们说&amp;quot;序列&amp;quot;就要考虑顺序, 即$001$和$100$是不同的串. 串可以是空串, 即长度为$0$的串, 空串通常记作$\varepsilon$.  我们也可用更加形式化的描述来定义语言.
 定义 语言
设$\Sigma$是一个字母表, $\Sigma^0={\varepsilon}$表示空串的集合, $\Sigma^n=\Sigma\times \Sigma\times\cdots\times \Sigma$为$n$个$\Sigma$的直积. 则$\Sigma$上的一个语言定义为$\Sigma^\ast=\bigcup\limits_{i\in\mathbb{N}}\Sigma^i$的子集.
 这里要注意的是$\Sigma^0$不是空集, 而是含有一个特殊的元素$\varepsilon$.
语言这个词可以说是一个相当糟糕的术语, 我们在这里不对这个术语本身进行过多的讨论, 但我们举例说明语言有多强大. 我们举一个有意义的例子.
例如, 一个语言可以用来表示所有的有向无环图, 我们试图用字母表$\Sigma={0,1}$上的语言来对图进行编码. 首先我们需要表示图$G=(V,E)$中的$V$, 我们约定$\dagger$之前的部分表示图中每个点的名称的长度$v$, 而$\dagger$之后依次的每个长度为$v$的连续子串表示图所有点的名称. 在所有的名称后, 我们用另一个$\dagger$作为分割, 其后依次的每个长度为$2v$子串表示一条有向边.</description>
    </item>
    
    <item>
      <title>计算复杂性(0) 目录</title>
      <link>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A70-%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 04 Mar 2019 21:29:13 +0000</pubDate>
      
      <guid>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A70-%E7%9B%AE%E5%BD%95/</guid>
      <description>写在前面 该笔记是我学习计算复杂性课程以及阅读相关书籍的过程中整理的笔记及个人理解. 整理成笔记除了加深我的个人理解外, 在这里分享给大家, 一方面也是是希望更多人能够理解这些内容, 感受这个世界为我们准备的惊喜. 另一方面也是为现在或是将来准备学习计算机的同学展示他们或许没有接触到的计算机科学的一角, 让大家知道计算机科学内涵的深度和广度, 能够看到Coding以外其他的东西, 也许能改变他们以后的人生路径. 注意, 本文不能替代任何课程, 教材或论文, 想要真正学习计算复杂性知识, 还是需要通过正规途径学习. 除此之外, 计算复杂性是密码学等一系列计算机理论课程的基础, 想要从事计算机理论方面的研究, 该课程是技能树上必点的技能.
Thanks to Prof. Fu (Yuxi Fu) at SJTU for giving us wonderful lectures.
如何学习? 不要沉溺于哲学问题(虽然可以作为兴趣偶尔讨论), 形式科学就要有形式科学该有的样子, 能从公理中得出的问题才是你该思考的问题.
目录 目前目录中列出的是我个人至少知道要研究些什么的内容, 实际上这里远不止这么一点, 后续的内容我会在学习完毕相应内容后再补充.
 自动机与正则语言 图灵机模型与可计算性 NP完备性 空间复杂性 多项式谱系 电路复杂性 随机化计算 扩展图和去随机化 计数复杂性 量子计算 交互证明 密码学 PCP定理  主要参考书目  Introduction to the Theory of Computation, Michael Sipser Computational Complexity: A Modern Approach, Sanjeev Arora and Boaz Barak  </description>
    </item>
    
  </channel>
</rss>
