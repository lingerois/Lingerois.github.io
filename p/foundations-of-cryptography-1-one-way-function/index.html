<!DOCTYPE html>
<html lang="zh-cn">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='The note of Oded Goldreich&#39;s Legendary Book Foundations of Cryptography. Chapter 2, Computational Difficulty'><title>Foundations of Cryptography 1 One-Way Function</title>

<link rel='canonical' href='https://flyzebraV.github.io/p/foundations-of-cryptography-1-one-way-function/'>

<link rel="stylesheet" href="/scss/style.min.css"><meta property='og:title' content='Foundations of Cryptography 1 One-Way Function'>
<meta property='og:description' content='The note of Oded Goldreich&#39;s Legendary Book Foundations of Cryptography. Chapter 2, Computational Difficulty'>
<meta property='og:url' content='https://flyzebraV.github.io/p/foundations-of-cryptography-1-one-way-function/'>
<meta property='og:site_name' content='Lingerois'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='密码学' /><meta property='article:published_time' content='2019-08-11T21:29:13&#43;00:00'/><meta property='article:modified_time' content='2019-08-11T21:29:13&#43;00:00'/><meta property='og:image' content='https://flyzebraV.github.io/cover.jpg' />
<meta name="twitter:title" content="Foundations of Cryptography 1 One-Way Function">
<meta name="twitter:description" content="The note of Oded Goldreich&#39;s Legendary Book Foundations of Cryptography. Chapter 2, Computational Difficulty"><meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image" content='https://flyzebraV.github.io/cover.jpg' />
    </head>
    <body class="">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.body.dataset.scheme = 'dark';
        } else {
            document.body.dataset.scheme = 'light';
        }
    })();
</script><div class="container main-container flex on-phone--column extended article-page with-toolbar">
            <aside class="sidebar left-sidebar sticky">
    <button class="hamburger hamburger--spin" type="button" id="toggle-menu" aria-label="Toggle Menu">
        <span class="hamburger-box">
            <span class="hamburger-inner"></span>
        </span>
    </button>

    <header class="site-info">
        
            <figure class="site-avatar">
                
                    
                    
                    
                        
                        <img src="/img/avatar_hu35558f041b6536b2cd39e6c0914e7c8e_3946_300x0_resize_box_2.png" width="300"
                            height="300" class="site-logo" loading="lazy" alt="Avatar">
                    
                

                
            </figure>
        
        <h1 class="site-name"><a href="https://flyzebraV.github.io/">Lingerois</a></h1>
        <h2 class="site-description">Fatal fate, doomed doom.</h2>
    </header>

    <ol class="menu" id="main-menu">
        
        
        

        <li >
            <a href='/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="5 12 3 12 12 3 21 12 19 12" />
  <path d="M5 12v7a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-7" />
  <path d="M9 21v-6a2 2 0 0 1 2 -2h2a2 2 0 0 1 2 2v6" />
</svg>



                
                <span>Home</span>
            </a>
        </li>
        
        

        <li >
            <a href='/about/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="7" r="4" />
  <path d="M6 21v-2a4 4 0 0 1 4 -4h4a4 4 0 0 1 4 4v2" />
</svg>



                
                <span>About</span>
            </a>
        </li>
        
        

        <li >
            <a href='/archives/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <rect x="3" y="4" width="18" height="4" rx="2" />
  <path d="M5 8v10a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-10" />
  <line x1="10" y1="12" x2="14" y2="12" />
</svg>



                
                <span>Archives</span>
            </a>
        </li>
        
        

        <li >
            <a href='/comment/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-messages" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M21 14l-3 -3h-7a1 1 0 0 1 -1 -1v-6a1 1 0 0 1 1 -1h9a1 1 0 0 1 1 1v10" />
  <path d="M14 15v2a1 1 0 0 1 -1 1h-7l-3 3v-10a1 1 0 0 1 1 -1h2" />
</svg>



                
                <span>Comment</span>
            </a>
        </li>
        
        

        <li >
            <a href='/search/'>
                
                    <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



                
                <span>Search</span>
            </a>
        </li>
        

        
            <li id="dark-mode-toggle">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="8" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="16" cy="12" r="2" />
  <rect x="2" y="6" width="20" height="12" rx="6" />
</svg>



                <span>Dark Mode</span>
            </li>
        
    </ol>
</aside>

            <main class="main full-width">
    <div id="article-toolbar">
        <a href="https://flyzebraV.github.io/" class="back-home">
            <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



            <span>Back</span>
        </a>
    </div>

    <article class="has-image main-article">
    <header class="article-header">
        <div class="article-image">
            <a href="/p/foundations-of-cryptography-1-one-way-function/">
                
                    <img src="/cover.jpg" loading="lazy" alt="Featured image of post Foundations of Cryptography 1 One-Way Function" />
                
            </a>
        </div>
    

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%AF%86%E7%A0%81%E5%AD%A6/" >
                密码学
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/foundations-of-cryptography-1-one-way-function/">Foundations of Cryptography 1 One-Way Function</a>
    </h2>

    
    <h3 class="article-subtitle">
        The note of Oded Goldreich&#39;s Legendary Book Foundations of Cryptography. Chapter 2, Computational Difficulty
    </h3>
    <footer class="article-time">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <time class="article-time--published">Aug 11, 2019</time>
    </footer></div>
</header>

    <section class="article-content">
    <p>One-way funtion is a funtion which is easy to compute but hard to invert. Here &ldquo;easy&rdquo; and &ldquo;hard&rdquo; means the lower bound of its computational complexity. The existence of one-way function is the necessary condition of the existence of modern cryptography schemes.</p>
<!-- more -->
<p><strong>Some Information about the Course</strong></p>
<p>In this course, we mainly talk about the foundation of Cryptography. The whole course includes the conditions of the existence of cryptography, the provable security of cryptosystems, the general construction method of cryptosystems. Basic knowledge of probability theory, computational complexity is necessary for this course.</p>
<p>This serie of notes mainly follows Goldreich&rsquo;s book <em>Foundations of Cryptograph</em>, which usually being regarded sealed. Actually with some basic knowledge about computational complexity and being familiar with those &ldquo;arguments&rdquo;, this book is not quite hard to read.</p>
<p>Furthermore, since Goldreich&rsquo;s book has been finished for several years, newly research results are not included in it. Results being found in resent years has been added by me in the notes. In fact, this is not the note of a single course. It is a set of notes for several cryptographic courses and textbooks. Some of the contents are beyond any of the courses the writer have taken.</p>
<p>Thanks to Mr. Yu and Mrs. Liu at SJTU for giving us wonderful cryptographic courses.</p>
<p><strong>Some Information about the Symbols</strong></p>
<p>Never be confused with the symbol $\to$. Though in math we always use $\to$ between the definitional domain and range, $\to$ here in the series of article often means the output of a algorithm. Algorithms are different with functions if we consider the complexity of it. And algorithms can be probablistic, that is, the outputs can be different even if the inputs are the same. Because of this, $=$ is meaningless. So we took the assignment operator from pseudocode $\to$ and $\leftarrow$ to denote the output of an algorithm.</p>
<p>We are not going to write too many conditions in a probabilistic formula. We sometimes write conditions by distributions under the simbol $\Pr$.</p>
<p>As for make of a probabilistic distribution like $U_n$, it has two means. Firstly, it denotes a distribution as it is. E.g. Random variable $X$ sampled by $U_n$ is denoted by $X\leftarrow U_n$, then we for each string $x\in U_n$ we have
$$
\Pr[x\in U_n]=\frac 1 {2^n}
$$
In other situations, these kind of mark can represent an anonymous random variable sampled from the distribution it denotes. We must make it clear that in the same math block, same mark of distribution $D$ always represents the same anonymous random variable sampled from $D$. For different anonymous random variable sampled from the same distribution $D$, we can use superscript to distinguish them. E.g. $D^{(1)}, D^{(2)},\cdots,D^{(m)}$.</p>
<p><strong>Some information about Abbreviations and Terms</strong></p>
<p>We presume that &ldquo;neglible&rdquo; is well-known. A function $p: \mathbb N\to [0,1]$  is called overwhelming if $1-p$ is negligible.</p>
<p>&ldquo;PPT&rdquo; stands for probalistic polynonial time, it means the function runs on a probalistic turing machine for polynomial time. The error probability is not included in &ldquo;PPT&rdquo;, it usually will be state later.</p>
<h1 id="one-way-function">One-Way Function</h1>
<h2 id="strong-one-way-function">Strong One-way Function</h2>
<p>The existence of cryptography is based on $\mathbf P\neq \mathbf{NP}$. But $\mathbf P\neq \mathbf{NP}$ is not enough, cryptography asks for stronger precondition, that is the existence of (Strong) <strong>One-way Function</strong>.</p>
<blockquote>
<p><strong>Strong One-way Function</strong> (OWF)</p>
<p>A function $f:{0,1}^\ast\to {0,1}^\ast$ is a strong one-way function if it is</p>
<ol>
<li><strong>Easy to compute</strong>: There is a deterministic polynomial-time algorithm $\mathsf{EvalF}$ such that for all $n$ and all $x\in{0,1}^n$ we have $\mathsf{EvalF(x)} = f(x)$.</li>
<li><strong>Hard to invert</strong>: There is no probabilitistic polynomial-time algorithm could invert the function with probability better than $\mathsf{negl(n)}$.</li>
</ol>
</blockquote>
<p>The second property can be restate more formally as</p>
<blockquote>
<p>There is no PPT algorithm $\mathcal {A}$ satisfy
$$
\Pr[\mathcal A(1^n,f(U_n))\in f^{-1}(f(U_n))]&gt;\frac{1}{n^c}
$$
for any $c&gt;0$.</p>
</blockquote>
<p>When you see a distribution been used as a random variable in a probabilitistic formula, it means you first sample once from that distribution and use the result as a random variable. It&rsquo;s easy to understant this since we do this just because we don&rsquo;t want to give the random variable a explicit name.</p>
<p><kbd>!</kbd> Another thing to pay attention to is that $f$ is defined for all $n$. Or wey say, $f$ is <strong>uniform</strong>.</p>
<p>As it is shown in the definition, a strong one-way function cannot be revert efficiently in average-case. That is, the function might somehow be inverted by a algorithm once, but hard on average.</p>
<blockquote>
<p><strong>Theorem</strong></p>
<p>If strong one-way function exists, then $\mathbf{P}\neq \mathbf{NP}$.</p>
</blockquote>
<p><strong>Proof</strong>: Suppose $\mathbf{P}=\mathbf{NP}$ and there exists an one-way function $f:{0,1}^\ast\to {0,1}^\ast$. Then decide
$$
L={\langle x^\ast,y\rangle| \exists x:x^\ast\sqsubset x \text{and} f(x)=y}
$$
$L$ is the collection of tuples like $\langle x^\ast, y\rangle$ that $x^\ast$ is the prefix of some $x$ that $f(x)=y$. Clearly $x$ itself is a certificate, so $L\in \mathbf{NP}$. But we have $\mathbf{P}=\mathbf{NP}$, so for every $y$, we can recover $x$ one bit by one bit. This can be done by call the oracle of $\mathcal O_L$. To invert $y$, we firstly ask $\langle 0, y\rangle$. If it returns $0$ then we ask $\langle 10, y\rangle$, otherwise we ask $\langle 00, y\rangle$.</p>
<p>However, there&rsquo;s another kind of one-way function, which sounds weaker that the previous defined one.</p>
<h2 id="weak-one-way-function">Weak One-Way Function</h2>
<blockquote>
<p><strong>Weak One-Way Function</strong></p>
<p>A function $f:{0,1}^\ast\to {0,1}^\ast$ is a one-way function if it is</p>
<ol>
<li>
<p><strong>Easy to compute</strong>: There is a deterministic polynomial-time algorithm $\mathsf{EvalF}$ such that for all $n$ and all $x\in{0,1}^n$ we have $\mathsf{EvalF(x)} = f(x)$.</p>
</li>
<li>
<p><strong>Slightly Hard to invert</strong>: There exists a polynomial $p(\cdot)$ such that for every PPT algorithm $\mathcal A$ and all sufficiently large n&rsquo;s,
$$
\Pr[\mathcal A(f(U_n,1^n)\notin f^{-1}(f(U_n))]&lt;1-\frac 1{p(n)}
$$</p>
</li>
</ol>
</blockquote>
<p>See, it&rsquo;s not &ldquo;very hard&rdquo; to invert weak one-way function. But pay attention that every algorithm shares the same $p(\cdot)$ in the definition. It means that every algorithms could only invert the function correctly with a upper bound probability. We can regard it as a &ldquo;gap&rdquo;.</p>
<p>If you are familiar with PCP theorem, you might think you there should be someway to amplify the gap. Then we can construct a strong one-way function by the given weak one-way function.</p>
<h2 id="one-way-function-defined-for-some-lengths">One-Way Function Defined for Some Lengths.</h2>
<p>We could define one-way function for some lengths. Let $I\in \mathbb N$, then $I$ contains some natural numbers. We define the successor of $n$ in $I$ the minimal number in $I$ that is larger than $I$, denoted by $s_I(n)$.</p>
<p>E.g. Let $I= {2,3,7,9,10,12,14,\cdots}$, then $s_I(8)=9$.</p>
<p>$I$ is called polynomial-time-enumerable if there exists a $poly$-time turing machine that on input $n$ output $1^{S_I(n)}$.</p>
<p>To modify the definition of strong/weak one way function, change &ldquo;every $n$&rdquo; to &ldquo;every $n\in I$ we get the definiton of strong/weak one-way functions for some lengths.</p>
<p><strong>Fact</strong> One-Way function for polynomial-time-enumerable $I$ can be easily transformed to the original one-way function.</p>
<blockquote>
<p><strong>Theorem</strong></p>
<p>Let $f(\cdot)$ be a one way function defined for lengths of polynomial-time-enumerable set $I$. Let $x=x^\prime x^&quot;$, where $x^\prime$ is the longest prefix of $x$ with length in $I$. Define
$$
g(x)=f(x^\prime)x^&rdquo;
$$
Then $g(x)$ is a one-way function.</p>
</blockquote>
<p><strong>Proof</strong>: The proof is simple, which is omitted here. But we review the basic thought of the proof. The technique used here is reduction. Suppose there is a algorithm $\mathcal A$ that invert $g(\cdot)$ efficiently, then we call construct a efficient algorithm $\mathcal A^\prime$ which could invoke $\mathcal A$ polynomial times and invert $f(\cdot)$ efficiently.</p>
<p><kbd>!</kbd> This is the basic ideal for strong one-way function. As for weak one-way function, the basic idea is similar.</p>
<h2 id="length-regular--length-preserving-one-way-function">Length-Regular &amp; Length-Preserving One-Way Function</h2>
<p>The following two definitions can be used to both strong &amp; weak one-way functions.</p>
<blockquote>
<p><strong>Length-Regular One-Way function</strong></p>
<p>A one-way function is length-regular if for every $|x_1|=|x_2|$, it holds that $|f(x_1)|=|f(x_2)|$.</p>
</blockquote>
<blockquote>
<p><strong>Length-Preserving One-Way function</strong></p>
<p>A one-way function is length-preserving if for every $x$, it holds that $|x|=|f(x)|$.</p>
</blockquote>
<p>Given a one-way function, we can construct a length-preserving one-way function by the following 2 steps. First given onw-way function $f(\cdot)$, we first construct a length-preserving function $g$ by adding the pad $10^\ast$
$$
g(x)\doteq f(x)10^{p(|x|)-|f(x)|}
$$
Where $p(\cdot)$ is the indicator of how many 0&rsquo;s we are going to add. Then we transform $g$ to a length-preserving one-way function $g^\prime$.
$$
g^\prime(x^\prime x^&quot;)\doteq g(x^\prime), \quad\text{where } |x^\prime x^&quot;|=p(|x^\prime|)+1
$$
We&rsquo;ve done. The one-wayness of $g^\prime$ can be also proved by reduction.</p>
<p>But the previous technique might not preserving the 1-1 of a one-way function, as for 1-1 one-way fucntion $f$, the first step do construct a 1-1 length-regular one-way function. But the second step break the 1-1 attribute.</p>
<h2 id="non-uniformly-one-way-function">Non-uniformly One-Way Function</h2>
<p>$\mathbf{BPP}\subseteq \mathbf{P}_{/\text{poly}}$ as we known, a one-way function might still be invert efficiently by an non-uniform algorithm. If we design cryptosystem based on one-way function, it might still be analysis by using non-uniform algorithms. How strong are you going to define cryptosystem? It&rsquo;s up to you. You might still define security means can&rsquo;t be efficiently analized by quantum computers…</p>
<p>Non-uniformly one-way function is a stronger version of one-way function, it is those one-way functions has non-uniform one-wayness, which means it can&rsquo;t be revert efficiently by a non-uniform algorithm. Notice that non-uniform algorithms are deterministic if they are represented by circuit families.</p>
<blockquote>
<p><strong>Non-uniformly One-Way Function</strong></p>
<p>A function $f:{0,1}^\ast\to {0,1}^\ast$ is a strong one-way function if it is</p>
<ol>
<li>
<p><strong>Easy to compute</strong>: There is a deterministic polynomial-time algorithm $\mathsf{EvalF}$ such that for all $n$ and all $x\in{0,1}^n$ we have $\mathsf{EvalF(x)} = f(x)$.</p>
</li>
<li>
<p><strong>Hard to invert</strong>: For all $poly$-size circuit family ${C_n}$  , polynomial $p(\cdot)$ and efficient large $n$, it holds that
$$
\Pr[C_n(f(x))\in f^{-1}(f(x))]&lt;\frac 1 {p(n)}
$$</p>
</li>
</ol>
</blockquote>
<p>Look, to compute the function, a $\mathbf {BPP}$ algorithm is enough, but even a non-uniform circuit familiy of $poly$-size cold invert it.</p>
<h1 id="weak-one-way-functions-imply-strong-ones">Weak One-Way Functions Imply Strong Ones</h1>
<blockquote>
<p><strong>Theorem</strong></p>
<p>Weak one-way function exists if and only if strong one-way function exitst.</p>
</blockquote>
<p>Not all weak one-way functions are strong one-way functions, refer to Goldreich&rsquo;s textbook for a counterexample. And $\Leftarrow$ direction is trivial, so we focus on prove the $\Rightarrow$ direction.</p>
<p>Let $f$ be a weak one-way function with $p(\cdot)$ to be guaranteed by definition. Then we might construct
$$
g(x_1,\cdots,x_{t(n)})\doteq (f(x_1),\cdots,f(x_{t(n)}))
$$</p>
<p>where $t(n)=n\cdot p(n)$ .</p>
<h2 id="naive-proof">Naive Proof</h2>
<p>It is obvious that $g$ is easy to compute. As for invertion, one might think the success probability is less than $(1-\frac{1}{p(n)})^{n\cdot p(n)}$. This is not right since it is based on the assumption that the algorithm invert $g$ works by invert every $f(x_i)$ independently, which cannot be justified.</p>
<h2 id="right-proof">Right Proof</h2>
<p>The fact is the construction is right but the proof is wrong. A detailed right proof is given in the following. Suppose we have the algorithm $\mathcal B$ to invert $g$ efficiently, that is
$$
\Pr[\mathcal B(g(U_m))\in g^{-1}(g(U_m))]&gt;\frac 1{q(m)}
$$
then as for $m=n^2p(n)$ there is
$$
\Pr[\mathcal B(g(U_{n^2p(n)}))\in g^{-1}(g(U_{n^2p(n)}))]&gt;\frac{1}{q(n^2p(n))}
$$</p>
<h3 id="construct-independent-inversion-procedure">Construct Independent Inversion Procedure</h3>
<p>The basic idea is to using the invert algorithm severala times to change the non-independently inversion to independently inversion by a procedure $I$. $I$ works as follows:</p>
<blockquote>
<p><strong>Procedure $I$</strong></p>
<p><em>Input</em>: $y$</p>
<ol>
<li>$n\leftarrow |y|$</li>
<li><strong>for</strong> $i=1$ to $t(n)$ <strong>do</strong>
<ol>
<li>$x_1\leftarrow U_n, x_2\leftarrow U_n,\cdots,x_{t(n)}\leftarrow U_n$</li>
<li>$z_1,z_2,\cdots,z_{t(n)}\leftarrow \mathcal B(f(x_1), \cdots, f(x_{i-1}), y,f(x_{i+1}),\cdots,f(x_{t(n)}))$</li>
<li><strong>if</strong> $f(z_i)=y$ <strong>then return</strong> $z_i$</li>
</ol>
</li>
<li><strong>end for</strong></li>
</ol>
</blockquote>
<p>Some comments:</p>
<p>&ldquo;<strong>return</strong> $x$&rdquo; means write $x$ on the output tape and halt for a turing machine (since algorithms &amp; procedures can be regard as turing machines).</p>
<p>The basic idea here is: If we try to invert some $f(x_i)$ in the output of $g$, $y_i$ must be tangled with other $f(x_j)$&rsquo;s, so here we try to put $y=f(x_i)$ to all the places to get the &ldquo;best chance&rdquo;. And by using procedure $I$ for each $f(x)$, we are going to invert them of independently.</p>
<h3 id="averaging-arguments-for-successful-inversions">Averaging Arguments for Successful Inversions</h3>
<p>We define another polynomial $a(n)\doteq 2n^2\cdot p(n)\cdot q(n^2p(n))$, and we are going to invoke $I$ for $a(n)$ times. It is easy to findout why $a(n)$ times by rewriting $a(n)$ as $a(n)=2\cdot t(n)\cdot q(m)$. According the previous argument, mes we can construct an invert algorithm $\mathcal A$ for $f(\cdot)$ BY  invoking procedure $I$ for $a(n)$ times. For an input $y=f(x)$,</p>
<p>$\mathcal A(y)$ halts whenever $I(y)$ halts with an output. If every invoking of $I(y)$ halts without any output, $\mathcal A$ just simply guess an invert of $y$.</p>
<p>The first question we are going to ask is with how much confidence you are going to believe $I$ inverts its input $y=f(x)$ correctly? Well, since $\mathcal B$ is a good algorithm for inverting $g$, it will invert $g$ correctly with probability at least $\frac 1 {q(m)}$. Recall that iterating for $i=1$ to $t(n)$ just helps to get the best chance for invert $y=f(x)$, so the probability to invert $y$ by $I$ will success with probability better than $\frac 1 {q(m) t(n)}$ where $m=n^2p(n)$. This can be done by basic averaging argument. Then it is quite clear we must try $I$ for about $q(m)t(n)=n\cdot p(n)\cdot q(n^2p(n))$ times to get some good enougth probability, this is where $a$ comes from.</p>
<p>As it is shown in the article <em>Averaging Argument</em>, we are going to devide $x\in{0,1}^n$ into &ldquo;good ones&rdquo; and &ldquo;bad ones&rdquo;,  we mark the collect of goodones as $S_n$, which defines as
$$
S_n\doteq\left{(f(x))\in f^{-1}(f(x))]&gt;\frac{n}{a(n)}\right}
$$
And the rest of strings are &ldquo;bad ones&rdquo;. To understand why strings in $S_n$ are &ldquo;good ones&rdquo;,  the reduction for $\mathbf{RP}$ might be help and the detailed explanation will be shown in next part.</p>
<p>Now we are going to focus on the size of $S_n$. Since $S_n$ collects all the good ones, why might guess if the input $f(x_1),\cdots,f(x_{t(n)})$ of $g$ satisfy that all $x_1$ come from $S_n$, then this will be easy to invert. Otherwise it would be hard to invert. According to this basic ideal, we define
$$
s(n)\doteq \Pr[g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))]&gt;\frac{1}{q(n\cdot t(n))}
$$
And seperate it into two parts, that is
$$
s_1(n)\doteq \Pr [g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))\wedge(\exists i: U^{i}_n\notin S_n)]
$$
and
$$
s_2(n)\doteq \Pr[g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))\wedge(\forall i: U^{i}_n\in S_n)]
$$
It is clear that $s(n)=s_1(n)+s_2(n)$.</p>
<p><strong>Probability Bound for $s_1(n)$</strong></p>
<p>Though deducing process is quite long, it is really simple by recalling that &ldquo;try to put $y=f(x_i)$ to all the places to get the &lsquo;best chance&rsquo;&rdquo;. We even could immediatly guess that
$$
s_1(n)=\sum^{n\cdot p(n)}<em>{i=1}\max{\Pr[I(f(x))\in f^{-1}(f(x))]}
$$
The detailed procedure are shown in the following:
$$
\begin{align}
s_1(n)
&amp;=\Pr[\exists i:\mathcal B(g(U</em>{n\cdot t(n)})\in g^{-1}(g(U_{n\cdot t(n)}))\wedge(U^{(i)}_n\notin S_n)] \<br>
&amp; \leq \sum^{n\cdot p(n)}_{i=1}\Pr[\mathcal B(g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))\wedge(U^{(i)}_n\notin S_n)] \<br>
&amp;\leq \sum^{n\cdot p(n)}_{i=1}\sum_{x\notin S_n}\Pr[\mathcal B(g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))\wedge(U^{(i)}_n\neq x)] \<br>
&amp;\leq \sum^{n\cdot p(n)}_{i=1}\sum_{x\notin S_n}\Pr[U^{(i)}_n=x]\cdot\Pr[\mathcal B(g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))|U^{(i)}_n=x] \<br>
&amp;\leq \sum^{n\cdot p(n)}_{i=1} \max_{x\notin S_n}{\Pr[\mathcal B(g(U_{n\cdot t(n)}))\in g^{-1}(g(U_{n\cdot t(n)}))|U^{(i)}_n=x]} \<br>
&amp;\leq \sum^{n\cdot p(n)}_{i=1} \max_{x\notin s_n}{\Pr[I(f(x))\notin f^{-1}(f(x))]} \<br>
&amp;\leq n\cdot p(n)\cdot \frac{n}{a(n)} \<br>
&amp;= \frac{n^2\cdot p(n)}{a(n)}
\end{align}
$$</p>
<p>While the last equality comes from our assumption.</p>
<p>Next, we are going to prove that $|S_n|&gt;(1-\frac{1}{2p(n)})\cdot 2^n$</p>
<p>Notice that
$$
\frac 1{q(n^2 p(n))}&lt;s(n)=s_1(n)+s_2(n)\leq \frac{1}{2q(n^2p(n))}+s_2(n)
$$
If we assume $|S_n|\leq (1-\frac 1 {2p(n)})\cdot 2^n$, then
$$
\begin{align}
s_2(n) &amp;\leq \Pr[\forall i:U^{(i)}_n\in S_n]\<br>
&amp;\leq (1-\frac{1}{2p(n)})^{n\cdot p(n)}\<br>
&amp;&lt; \frac 1 {2^{n/2}} &lt; \frac{n^2\cdot p(n)}{a(n)}
\end{align}
$$
holds for efficient large $n$.</p>
<p>By contradiction
$$
\frac 1{n^2\cdot q(n)}&lt;s(n)&lt;s_1(n)+s_2(n)&lt;\frac 1{n^2\cdot q(n)}
$$
we have
$$
|S_n|&gt;(1-\frac 1 {2p(n)})\cdot 2^n
$$</p>
<h3 id="bound-the-lower-probability-of-mathcal-a">Bound the lower probability of $\mathcal A$</h3>
<p>We now bound the success invert probability of $\mathcal A$. For $x\in S_n$, the failure probability can be bounded by
$$
\Pr\limits_{x\leftarrow U(S_n)}[\mathcal{A}(f(x))\notin f^{-1}(f(x))]&lt;(1-\frac{n}{a(n)})^{a(n)}&lt;\frac 1{2^n}
$$
Now its easy to bold the success probability of $\mathcal A$.
$$
\begin{align}
&amp;\quad,\Pr[\mathcal A(f(x))\in f^{-1}(f(x))] \<br>
&amp;\geq \Pr[\mathcal A(f(x))\in f^{-1}(f(x)) \wedge(U_n\in S_n)] \<br>
&amp;= \Pr[\mathcal A(f(x))\in f^{-1}(f(x))|U_n\in S_n]\cdot\Pr[U_n\in S_n] \<br>
&amp;\geq (1-\frac 1 {2p(n)})\cdot(1-2^{-n}) &gt; 1-\frac 1{p(n)}
\end{align}
$$
Which is contradicted with the fact that $f$ is promised to be failed to invert with probability of $p(n)$. We&rsquo;ve done the proof.</p>
<h2 id="summary-for-one-way-function">Summary for One-Way Function</h2>
<p>As we have learned, there is a universal construction method for strong one-way function by weak one-way function. We are going to use the word &ldquo;one-way function&rdquo; in future discussing.</p>
<p>Futhermore, since we&rsquo;ve known that one-way functions for polynomial-time-enumerable sets exists imply one-way function for all lengths exists. And the existence of the later implies the existence of length-regular or length-preserving functions. We might use these attributes without declaration.</p>
<h2 id="universal-one-way-function">Universal One-Way Function</h2>
<p>We can define a function
$$
f_{\text{uni}}(\llcorner\boldsymbol M\lrcorner,x)
\doteq(\llcorner\boldsymbol M\lrcorner,\boldsymbol M(x))
$$
where $\boldsymbol M$ is a turing machine as $\llcorner\boldsymbol M\lrcorner$ is its description. This is called a universal one-way function, which is obviously computable on a universal TM with a step counter. It is interesting that if there is any one-way function $g$, so is $f_{\text{uni}}$.</p>
<p>Furthermore, we can use $f_{\text{uni}} $ to construct the polynomial-time computable strong one-way function.</p>
<h2 id="one-way-function-family">One-Way Function Family</h2>
<p>Well if we put some of one-way functions together, we get a collection of one-way funtions. This is meaningless unless we have a good way to compute them by a single evaluation function which halts in $poly$-time. If such a function do exists, with some extra attributes, the collection would be quite useful. Based on this main idea, we define one-way function family.</p>
<blockquote>
<p><strong>One-Way Function Family</strong></p>
<p>A collection of functions ${f_i:D_i\to{0,1}^\ast | i\in I}$ is called strongly (resp., weakly) one-way if there exists three PPT algorithms $\mathcal G,\mathcal S,\mathcal E$ satisfy</p>
<ol>
<li>The generation algorithm $\mathcal G $: given the input $1^n$, output a random variable $i$ from $I_n=I\cap {0,1}^n$.</li>
<li>The sample algorithm  $\mathcal S$: given the input $1^n$ and $I_n$, output a random value $x$ from $D_i$.</li>
<li>Then evaluation algorithm $\mathcal E$: given the input $1^n, I_n, x$, output $f_i(x)$ correctly all the time.</li>
</ol>
<p>and one-wayness:</p>
<ol>
<li>For every PPT algorithm $\mathcal A$, every polynomial $p(\cdot)$ and all sufficient large $n$&rsquo;s, it holds that</li>
</ol>
<p>$$
\Pr\limits_{i\leftarrow \mathcal S(1^n)\ x\leftarrow\mathcal G(1^n,i)}[\mathcal A(i,f_{i}(x))\in f^{-1}_{i}(f_{i}(x))]&lt;\frac 1 {p(n)}
$$</p>
</blockquote>
<p>The definition is straight forward, but there are still somewhere to pay attention to.</p>
<p>As for the index set I, in order to efficiently sample from $I\cap {0,1}^n$ for all efficient large $n$, the size of $I$ has to be noticable, which means $|I\cap {0,1}^n|\geq 2^n/\text{poly}(n)$. The generation algorithm $\mathcal G$ don&rsquo;t have to sample $I_n$ uniformly at random on $I\cap {0,1}^n$. Likewise, the output of sample algorithm $\mathcal S$ on input $i$ do not necessarily distributed uniformly over $D_i$.</p>
<p>Did you find something wrong? The defintion of &ldquo;One-way function family&rdquo; doesn&rsquo;t mentioned that all the functions in it has to be one-way function! Furthermore, the inversion is hard with respect $\mathcal G$ and $\mathcal S$!</p>
<p>Here we recall the reduction of $\mathbf{RP}$ again. We can always construct a generation or sample algorithm that outputs <strong>YES</strong> with overwhelming probability by repeat $\mathcal G$ or $\mathcal S$ polynomial times. We are going to use this in the definition of trapdoor permutation family.</p>
<p><em><u>A Problem</u></em></p>
<p>Goldreich says &ldquo;without lost of generosity, $\mathcal E$ can be deterministic&rdquo;, but how comes that $\mathcal E$ evaluates right with just overwhelming probabilty in the definition of trapdoor one-way family? Why are they different?</p>
<h1 id="trapdoor-one-way-permutations">Trapdoor One-Way Permutations</h1>
<p>Goldreich didn&rsquo;t mentioned about non-permutation trapdoor one-way functions, so we&rsquo;are going to skip that (since its quite simple as well).</p>
<p>The idea of trapdoor, I think, comes from the certificate of an $\mathbf{NP}$ problem. With its trapdoor, the one-way function is easy to invert. This sounds like at least one inversion (since every image might have mutiple preimages) of such one-way function is a $\mathbf{NP}$ language. The trapdoor might sounds more like an advice since its same for all the inputs. But for one-way function family, I feel nature about regarding trapdoors as certificates.</p>
<p>For OWP family (One-Way Permutation family) with trapdoors, we are going to use the most convenient definition for cryptography.</p>
<blockquote>
<p><strong>Trapdoor Permutation Family</strong></p>
<p>Let $I\subseteq {0,1}^n$ and define $I_n=I\cap{0,1}^n$. A trapdoor permutation famility with indices in $I$ is a set of functions $\left{f_i:D_i\to D_i|i\in I\right}$ such that each $f_i$ is a permutation on the corresponding $D_i$. Such a collection is called a <strong>trapdoor permutation</strong> if there exist four PPT algorithms $\mathcal G, \mathcal S, \mathcal E, \mathcal E^{-1}$ such that the following five conditions hold:</p>
<ol>
<li>
<p>Index and trapdoor generation $\mathcal G$:
$$
\Pr[\mathcal G(1^n)\in I_n\times {0,1}^\ast]&gt;1-2^{-n}
$$</p>
</li>
<li>
<p>Random variable in domain sampling $\mathcal S$, for every $n\in\mathbb N$ and $i\in I_n$</p>
</li>
<li>
<p>$\Pr[\mathcal S(i)\in D_i]&gt;1-2^{-n}$</p>
</li>
<li>
<p>If the output of $\mathcal S$ is in $D_i$, then its distributed uniformly at random on $D_i$, that is
$$
\Pr[\mathcal S(i)=x|\mathcal{S}(i)\in D_i]=\frac1{|D_i|}
$$</p>
</li>
<li>
<p>Efficient evaluation $\mathcal E$, for every $n\in\mathbb N,i\in I_n$, and $x\in D_i$
$$
\Pr[\mathcal E(i,x)=f_i(x)]&gt;1-2^{-n}
$$</p>
</li>
<li>
<p>Hard to invert:</p>
</li>
</ol>
</blockquote>
<h1 id="hard-core-predicates">Hard-Core Predicates</h1>
<p>As we know, to invert a trapdoor one-way function is hard without giving the trapdoor. However, &ldquo;<strong>hard</strong>&rdquo; here means it is hard to get the exact inverse of an value. Though it&rsquo;s hard to invert one-way function, we may still get some information about it, which leads to unsecrity of constructing PKEs directly by using one-way permutations.</p>
<p>Luckily we have found that some bit of one-way are truly hard to predicate, we call those bits &ldquo;hard-core&rdquo;. By using the difficulty of predicate the hard-core of one-way permutation, we can construct PKEs which are secure enough.</p>
<blockquote>
<p><strong>Hard-Core Predicate</strong></p>
<p>A PPT computable predicate $b:{0,1}^\ast\to{0,1}$ is called a <strong>hard-core</strong> of a function $f$ if for every PPT algorithm $\mathcal A$, every polynomial $p(\cdot)$ and all sufficient large $n$, it holds that
$$
\Pr[\mathcal A(f(U_n))=b(U_n)]&lt;\frac{1}{2}+\frac 1 {p(n)}
$$</p>
</blockquote>
<p>Don&rsquo;t be confused with the word &ldquo;predicate&rdquo;; it just means a function with range ${0,1}$. As we can induce from the difinition, only one-way functions have hard-cores. Otherwise since $b$ is PPT computable, we could compute it by invert the functions first.</p>
<p>We can also define hard-core for a one-way function family.</p>
<blockquote>
<p><strong>Hard-Core Predicate for One-Way Function Family</strong></p>
<p>For one-way function family $(\mathcal G,\mathcal S ,\mathcal E)$, a $poly$-time alogrithm $\mathcal B:{0,1}^\ast\times {0,1}^\ast\to {0,1}$ is called a hard-core of the family if for every PPT algorithm $\mathcal A$, every polynomial $p(\cdot)$, and all sufficiently large n&rsquo;s,
$$
\Pr\limits_{i\leftarrow \mathcal G(1^n)\ x\leftarrow \mathcal S(1^n,i)}[\mathcal A(i,f_i(x))=\mathcal B(i,x)]&lt;\frac 12+\frac 1{p(n)}
$$</p>
</blockquote>
<h2 id="hard-core-for-any-one-way-function">Hard-Core for Any One-Way Function</h2>
<p>In this section, we are going to prove &ldquo;where there is a one-way function, there is a hard-core&rdquo;. The construction of the hard-core is based on a very simple idea of generalize the XOR lemma of statistical indistinguishable to computational indistinguishable.</p>
<blockquote>
<p><strong>Goldreich-Levin Theorem</strong></p>
<p>Let $f$ be an arbitrary strong one-way function, and let $g$ be defined as $g(x,r)=(f(x),r)$, where $|x|=|r|$. Then predicate $b=\bigoplus_{i=1}^{|x|}x\cdot r$ is a hard-core of function $g$.</p>
</blockquote>
<p>Well the proof of this theorem is quite long, but seems not difficult since the basic idea easy. Assume that there is some alogrithm $\mathcal A$ that predict $a$ with non-negligible probability, we are going to construct a algorithm $\mathcal B$ whom invokes $\mathcal A$ polynomial times and recover $x\in f^{-1}(y)$ bit by bit. We are going to prove a weaker theorem first in order to build up the intuition of this theorem.</p>
<h3 id="weaker-version-the-constant-successful-prdiction-probability--076"><strong>Weaker Version: The constant successful prdiction probability $&gt; 0.76$</strong></h3>
<p>We are going to show how to recover 1 bit by invoking the algorithm hard-core predicting algorithm $\mathcal A$ that satisfy
$$
\Pr[\mathcal A(f(x),r)=b(x,r)]&gt;0.75+\frac{1}{2p(n)}
$$
where $p(n)$ is a polynomial.</p>
<p>Since $r$ is uniformly random, $r\oplus e_i$ is uniformly random, where $e_i$ is an $n$-dimensional binary vector with $1$ in the $i$th component and $0$ in the others. We can use to $\mathcal A(f(x),r \oplus e_i)$ to predict $b(x,r\oplus e_i)$, and get the right result with probability $&gt; 0.75+\frac 1{2p(n)}$.</p>
<p>Since
$$
\begin{align}
\mathcal A(f(x),r)\oplus \mathcal A(f(x),r\oplus e_i) &amp;= b(x,r)\oplus b(x,r\oplus e_i) \<br>
&amp;= b(x,e_i) \<br>
&amp; = x_i
\end{align}
$$
Then we can constuct an algorithm $\mathcal B(f(x),r)=\mathcal A(f(x),r)\oplus \mathcal A(f(x),r\oplus e_i)$ and by simply using basic probabilistic theory or Chernoff bound, it holds that
$$
\Pr[\mathcal B(f(x),r)=x_i]&gt;\frac 1 2 +\frac 1 {p(n)}
$$
We can recover 1 bit of $x$ with noticable probability. By repeatly invoking $\mathcal B$ for polynomial times, we could recover all bits of $x$ with high enough probability.</p>
<h3 id="proof-of-goldreich-levin-theorem">Proof of <strong>Goldreich-Levin Theorem</strong></h3>
<p>Since we are going to work with the tool $\mathcal A$ that has higher probability, the previous introduced method cannot work.</p>
<p>I think Goldreich has introduced his intuition finely, so I&rsquo;m going to quote the contents in his book here, with some slightly modify to the symbols.</p>
<blockquote>
<p>What is required is <strong>an alternative way</strong> of suing the algorithm $\mathcal B$, a way that does not double the orighinal error probability of $\mathcal B$. They key idea is to generate the $r$&rsquo;s in a way that requires applying algorithm $\mathcal B$ only once per each $r$ (and $i$), instead of twice. Specifically, we shall use algorithm $\mathcal B$ to obtain a &ldquo;guess&rdquo; for $b(x,r\oplus e_i)$ and obtain $b(x,r)$ in a different way. The good news is that the error probability is no longer doubled, since we use $\mathcal B$ get a &ldquo;quess&rdquo; of $b(x,r\oplus e_i)$. The bad news is that we still need to know $b(x,r)$ for only one $r$ (or logarithmacally in |x| many r&rsquo;s), but the problem is that we nned to know (and hence guess) the values of $b(x,r)$ for polynomially many r&rsquo;s. An obvious way of guessing these $b(x,r)$&rsquo;s yields an exponentially vanishing success probability. Instead we generate these polynomially many r&rsquo;s such that, on one hand, they are &ldquo;sufficiently random,&rdquo; whereas, on the other hand, we can guess all the $b(x,r)$&rsquo;s with noticable success probability. Specifically, generating the r&rsquo;s in a particular <strong>pairwise-independent</strong> manner will satisfy both (seemingly contradictory) reqirements.</p>
</blockquote>
<p><strong>Back to the proof with some explaination</strong></p>
<p>Suppose there is an algorithm $\mathcal A$ holds that
$$
\Pr\limits_{x\leftarrow U_n\r\leftarrow U_n}[\mathcal A(f(x),r)=b(x,r)]&gt;\frac12+\frac1{p(n)}
$$
where $p(\cdot)$ is a polynomial and $|x|=n$.</p>
<p>We define a &ldquo;good&rdquo; subset of ${0,1}^n$. $S_n$ defines as
$$
S_n=\left{S_n|\Pr\limits_{r\leftarrow U_n}[\mathcal A(f(x),r)=b(x,r)]&gt;\frac 12+\frac1{2p(n)},x\in S_n \text{ is a constant}\right}
$$
We have proved that $|S_n|&gt;\frac1{2p(n)}\cdot 2^n$.</p>
<p>We set $l\doteq \lceil \log_2(2n\cdot p(n)^2+1)\rfloor$. We construct a algorithm $\mathcal B$ proceeds as follows:</p>
<ol>
<li>
<p>Sample $s^1,\cdots, s^l\in{0,1}^\ast $and $\sigma^1,\cdots, \sigma^l\in{0,1}$ uniformly at random.</p>
</li>
<li>
<p>For every one-empty set $J\subseteq [l]$, computes $r^J=\bigoplus_{j\in J} s_j$ and a bit $\rho^J=\bigoplus_{j\in J}\sigma_j$.</p>
</li>
<li>
<p>For every $i\in [n]$ and every non-empty $J \subseteq [l]$, computes
$$
z^J_i\leftarrow \rho^J\oplus G(y,r^J\oplus e_i)
$$</p>
</li>
<li>
<p>For evry $i\in[n]$, it sets $z_i$ to be the majority of the $z^J_i$ values.</p>
</li>
<li>
<p>Output $z=z_1\cdots z_n$.</p>
</li>
</ol>
<p>We have some comments. $\sigma_j$ is regard as the approximation of $b(x, s_j)$. It might sound wired since $\sigma_j$ is sampled uniformly at random. It sounds more like a &ldquo;guess&rdquo; and the probability of guessing right all can be computed:
$$
\Pr[\forall i\in[l]:\sigma_i=b(x,s_i)]= 2^{-l}&gt;\frac 1 {4n\cdot p(n)^2}
$$
Whereas, the tricky technique here is we are not going use reductions to get the correct guess. Actually, we are going to use &ldquo;democrative voting&rdquo;.</p>
<p>The basic idea is that since we can guess the hard-core rightly, we are going to guess one-bit of $x_i$ from $f(x)$ with rightly with probability better than $1/2$ by using $\mathcal A(x,r^J)\oplus \mathcal(x,r^J\oplus e_i)$. Using Chernoff bound is an bad idea since it force us to double the error probability. Luckily, at last we have sampled pairwise-independent $s^J$&rsquo;s and Chebyshev&rsquo;s indequality should be helpful.</p>
<p>We define a new variable $\zeta^J_i$. $\zeta^J_i = 1$ if and only if we use $r^J$ guesses $x_i$ correctly, which means $b(x,r^J)\oplus \mathcal B(f(x),r^J\oplus e_i)=x_i$. Since $b(x,r^J)\oplus b(x,r^J\oplus e_i)$, if follows that $\zeta^J =1 $ if and only if $G(f(x),r^J\oplus e_i)=b(x,r^J\oplus e_i)$. For $x\in S_n$, We have
$$
\begin{align}
\Pr\left[\sum_{J\subseteq[l]} \zeta^J\leq \frac m 2\right] &amp;\leq \Pr\left[\left|\sum_{J\subseteq[l]}\zeta^J-\left(\frac12+\frac1{2p(n)}\right)\cdot m\right|\geq ]\frac1{2p(n)m}\right] \<br>
&amp;\leq \frac{m\cdot \text{Var}[\zeta]}{\left(\frac1{2p(n)}\cdot m\right)^2} \<br>
&amp;\leq \frac{m\cdot \text{Var}[\zeta]}{\left(\frac1{2p(n)}\right)^2 \cdot (2n\cdot p(n)^2)} \<br>
&amp;= \frac 1{2n}
\end{align}
$$
And now its time to evaluate the probability of $z_1\cdots z_n=x_1\cdots x_n$,
$$
\begin{align}
\Pr[z_1\cdots z_n=x_1\cdots x_n|x\in S_n]&amp;\geq 1- \sum^n_{j=1}x\in \Pr[x\in S_n](\Pr[x_j\neq z_j] \<br>
&amp; =\frac {(1-\frac n{2n})}{4n\cdot p(n)^2}=\frac 1{8n\cdot p(n)^2}
\end{align}
$$
Every time we get the output, we just test. If the output is wrong, we try algorithm $\mathcal B$ again. Within polynomial times of invoking, the success probability will get to $2/3$.</p>
<h2 id="more">More</h2>
<h1 id="exercise">Exercise</h1>
<p>Please don&rsquo;t ask me for solutions, because I&rsquo;m solving them, too. I would like to give some hints for difficult problems after I&rsquo;ve done them.</p>
<ol>
<li>Prove that if one-way function exists, then $\mathbf{NP}\backslash\mathbf{BPP}\neq \emptyset$.</li>
<li>Prove that in the proof of <strong>Goldreich-Levin Theorem</strong>, for any $I,J\subseteq [l]$, $r^I$ and $r^J$ are independent.</li>
</ol>
<hr>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%AF%86%E7%A0%81%E5%AD%A6/">密码学</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>

    
</article>

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="has-image">
    <a href="/p/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%861-gsw13%E6%96%B9%E6%A1%88/">
        
        
            <div class="article-image">
                <img src="/p/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%861-gsw13%E6%96%B9%E6%A1%88/fog.3b9b2e32396518361399f058b7cdb81f_hu165ac214da6e531d826e0fd7ad766063_27843_250x150_fill_q75_box_smart1.jpg" 
                        width="250" 
                        height="150" 
                        loading="lazy" 
                        data-key="同态加密1 GSW13方案" 
                        data-hash="md5-O5suMjllGDYTmfBYt824Hw==">
                
            </div>
        

        <div class="article-details">
            <h2 class="article-title">同态加密1 GSW13方案</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>


    
        
    <link rel="stylesheet" href="https://unpkg.com/vssue/dist/vssue.min.css" />

<div id="vssue"></div>

<script src="https://unpkg.com/vue/dist/vue.runtime.min.js"></script>
<script src="https://unpkg.com/vssue/dist/vssue.github.min.js"></script>

<script>
    new Vue({
        el: "#vssue",
        render: (h) =>
            h("Vssue", {
                props: {
                    title: "Foundations of Cryptography 1 One-Way Function",
                    options: {
                        proxy: (url) => "https://cors-anywhere.azm.workers.dev/" + url,
                        owner: "lingerois",
                        repo: "lingerois.github.io",
                        clientId: "634f4b816590d54006ca",
                        clientSecret: "f6207230aed974ad5a146625cf68fbd956ed76c0",
                    },
                },
            }),
    });
</script>

    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2021 Lingerois
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="2.3.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
    <script>
        MathJax = {
          tex: {
            inlineMath: [["$", "$"]],
          },
          displayMath: [
            ["$$", "$$"],
            ["\[\[", "\]\]"],
          ],
          svg: {
            fontCache: "global",
          },
        };
      </script>
      <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
      <script
        id="MathJax-script"
        async
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"
      ></script>
</footer>
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >
            </main>
        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>

    </body>
</html>
