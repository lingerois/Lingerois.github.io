<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Lingerois</title>
    <link>https://flyzebraV.github.io/post/</link>
    <description>Recent content in Posts on Lingerois</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 11 Aug 2019 21:29:13 +0000</lastBuildDate><atom:link href="https://flyzebraV.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>同态加密1 GSW13方案</title>
      <link>https://flyzebraV.github.io/p/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%861-gsw13%E6%96%B9%E6%A1%88/</link>
      <pubDate>Sun, 11 Aug 2019 21:29:13 +0000</pubDate>
      
      <guid>https://flyzebraV.github.io/p/%E5%90%8C%E6%80%81%E5%8A%A0%E5%AF%861-gsw13%E6%96%B9%E6%A1%88/</guid>
      <description>GSW方案是由Craig Gentry1, Amit Sahai与Brent Waters于2013年提出的方案, 发表于论文[GSW13]中.
GSW方案确实如论文标题一样, 概念清晰明了, 其Intuition简单到一个刚学完线性代数的大一新生也能理解. GSW还支持基于属性的加密, 但本文中我们将不介绍这一部分内容.
当然, 完全理解GSW方案仍然需要用到一些比较进阶的知识, 如LWE问题的困难性等. 我们在本文中不会对这些知识做过多的介绍, 这些知识将在今后其他的博文中介绍.
Basic Intuition 密文的基本格式 最基本的GSW同态加密方案的私钥($sk$)是一个向量$\mathbf v\in\mathbb Z_q^N$, 而所有的明文$\mu_i\in{0,1}$都被加密一个矩阵$C_i\in\mathbb Z_q^{N\times N}$中, 其中$C_i$是以$v$为近似特征向量并以$\mu_i$为近似特征值的矩阵, 即我们要求 $$ C_i\mathbf v\approx \mu_i \mathbf v $$ 这里可以看出， 我们只需要挑选$\mathbf v$中非$0$的位(最好是选较大的位), 如第$j$位$v_j$, 并比较$v_j$与$\mu_iv_j$的值就可以解出$\mu_i$的值.
一个需要注意的地方就是, 虽然$\mu_i$取自${0,1}$, 但被视作是$\mathbb Z_q$中的元素, 因此具体的运算也是按照$\mathbb Z_q$的运算方式来进行.
我们也可以将噪声(error)显式地写出来, 记作 $$ C_i\mathbf v=\mu_i\mathbf v+\mathbf e $$ 其中$\mathbf e$是非常小的向量. 因此可以看出, 如果$\mathbf e$确实是一个较小的噪声, 那么我们就可以正确地解出$\mu_i$.
乘法同态性质 现在我们来验证该加密方案具有同态性质. 现在假设有两个密文$C_1, C_2$, 对对应的明文分别是$\mu_1,\mu_2$, 即 $$ \begin{aligned} C_1\mathbf v=\mu_1\mathbf v+\mathbf e_1 \newline C_2\mathbf v=\mu_2\mathbf v+\mathbf e_2 \end{aligned} $$ 其中$\mathbf e_1,\mathbf e_2$均为较小的噪声, 那么令$C^\times=C_1\cdot C_2$, 我们检验$C^\times$的解密结果 $$ \begin{aligned} C^\times\mathbf v &amp;amp;=(C_1\cdot C_2)\mathbf v \newline &amp;amp;=C_1(\mu_2\mathbf v+\mathbf e_2) \newline &amp;amp;=\mu_2(\mu_1\mathbf v+\mathbf e_1)+C_1\mathbf e_2\newline &amp;amp;= \mu_1\mu_2\mathbf v+\mu_2\mathbf e_1+C_1\mathbf e_2 \end{aligned} $$ 这里可以看出, $\mu_2\mathbf e_1$确实是一个比较小的噪声项, 但是要让$C^\times$的噪声比较小, 那么就需要让$C_1$是一个较小的矩阵(即其最大的元素较小), 我们稍后会解释如何做到这一点.</description>
    </item>
    
    <item>
      <title>计算复杂性(1) 自动机与正则语言</title>
      <link>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A71-%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80/</link>
      <pubDate>Tue, 05 Mar 2019 12:06:45 +0000</pubDate>
      
      <guid>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A71-%E8%87%AA%E5%8A%A8%E6%9C%BA%E4%B8%8E%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80/</guid>
      <description>计算问题 什么是计算机? 计算, 就是解决某个具体问题的算法, 得出相应的答案. 计算机就是能执行某个具体算法的机器. 即Computer就用来是Compute的机器. 此外, 讨论什么是机器, 对我们研究计算机科学毫无帮助, 你只需要知道, 计算机就是用来执行算法的机器. 我们要做的就是, 用最简单的理论模型, 最大程度的抽象化我们现有的计算机.
语言  定义 语言
一个字母表(alphabet)是一个非空有限集合, 该集合中的元素称为符号(symbol).
一个字母表$\Sigma$上的语言(language)是$\Sigma$中的元素构成的有限序列(称为串, 即string)的集合.
 例如字母表$\Sigma={0,1}$, 则我们可以定义一个$\Sigma$上的语言$L={x_1x_2\cdots x_n|\text{如果}x_i= 0,则x_{i+1}= 0}$, 则该语言为 $$ L={\varepsilon, 0,1,10,11,100,110,111,\cdots} $$ 即所有的$1$都出现在任何$0$之前的串. 其中, $\varepsilon$表示空串, 即长度为$0$的串.
这里要注意的是
 我们说&amp;quot;序列&amp;quot;就要考虑顺序, 即$001$和$100$是不同的串. 串可以是空串, 即长度为$0$的串, 空串通常记作$\varepsilon$.  我们也可用更加形式化的描述来定义语言.
 定义 语言
设$\Sigma$是一个字母表, $\Sigma^0={\varepsilon}$表示空串的集合, $\Sigma^n=\Sigma\times \Sigma\times\cdots\times \Sigma$为$n$个$\Sigma$的直积. 则$\Sigma$上的一个语言定义为$\Sigma^\ast=\bigcup\limits_{i\in\mathbb{N}}\Sigma^i$的子集.
 这里要注意的是$\Sigma^0$不是空集, 而是含有一个特殊的元素$\varepsilon$.
语言这个词可以说是一个相当糟糕的术语, 我们在这里不对这个术语本身进行过多的讨论, 但我们举例说明语言有多强大. 我们举一个有意义的例子.
例如, 一个语言可以用来表示所有的有向无环图, 我们试图用字母表$\Sigma={0,1}$上的语言来对图进行编码. 首先我们需要表示图$G=(V,E)$中的$V$, 我们约定$\dagger$之前的部分表示图中每个点的名称的长度$v$, 而$\dagger$之后依次的每个长度为$v$的连续子串表示图所有点的名称. 在所有的名称后, 我们用另一个$\dagger$作为分割, 其后依次的每个长度为$2v$子串表示一条有向边.</description>
    </item>
    
    <item>
      <title>计算复杂性(0) 目录</title>
      <link>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A70-%E7%9B%AE%E5%BD%95/</link>
      <pubDate>Mon, 04 Mar 2019 21:29:13 +0000</pubDate>
      
      <guid>https://flyzebraV.github.io/p/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A70-%E7%9B%AE%E5%BD%95/</guid>
      <description>写在前面 该笔记是我学习计算复杂性课程以及阅读相关书籍的过程中整理的笔记及个人理解. 整理成笔记除了加深我的个人理解外, 在这里分享给大家, 一方面也是是希望更多人能够理解这些内容, 感受这个世界为我们准备的惊喜. 另一方面也是为现在或是将来准备学习计算机的同学展示他们或许没有接触到的计算机科学的一角, 让大家知道计算机科学内涵的深度和广度, 能够看到Coding以外其他的东西, 也许能改变他们以后的人生路径. 注意, 本文不能替代任何课程, 教材或论文, 想要真正学习计算复杂性知识, 还是需要通过正规途径学习. 除此之外, 计算复杂性是密码学等一系列计算机理论课程的基础, 想要从事计算机理论方面的研究, 该课程是技能树上必点的技能.
Thanks to Prof. Fu (Yuxi Fu) at SJTU for giving us wonderful lectures.
如何学习? 不要沉溺于哲学问题(虽然可以作为兴趣偶尔讨论), 形式科学就要有形式科学该有的样子, 能从公理中得出的问题才是你该思考的问题.
目录 目前目录中列出的是我个人至少知道要研究些什么的内容, 实际上这里远不止这么一点, 后续的内容我会在学习完毕相应内容后再补充.
 自动机与正则语言 图灵机模型与可计算性 NP完备性 空间复杂性 多项式谱系 电路复杂性 随机化计算 扩展图和去随机化 计数复杂性 量子计算 交互证明 密码学 PCP定理  主要参考书目  Introduction to the Theory of Computation, Michael Sipser Computational Complexity: A Modern Approach, Sanjeev Arora and Boaz Barak  </description>
    </item>
    
  </channel>
</rss>
